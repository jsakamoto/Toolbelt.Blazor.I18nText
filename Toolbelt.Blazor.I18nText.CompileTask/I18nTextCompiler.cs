using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using Newtonsoft.Json;
using TinyCsvParser;
using TinyCsvParser.Mapping;
using Toolbelt.Blazor.I18nText.Internals;

namespace Toolbelt.Blazor.I18nText
{
    public class I18nTextCompiler
    {
        private const string GeneratedMarker = "// Generated by the Blazor I18n Text compiler";

        public bool Compile(IEnumerable<I18nTextSourceFile> srcFiles, I18nTextCompilerOptions options)
        {
            try
            {
                var i18textSrc = ParseSourceFiles(srcFiles, options);
                OutputTypesFiles(options, i18textSrc);
                OutputI18nTextJsonFiles(options, i18textSrc);
                return true;
            }
            catch (AggregateException e) when (e.InnerException is I18nTextCompileException compileException)
            {
                options.LogError(compileException.Message);
                return false;
            }
            catch (I18nTextCompileException compileException)
            {
                options.LogError(compileException.Message);
                return false;
            }
        }

        private static I18nTextSource ParseSourceFiles(IEnumerable<I18nTextSourceFile> srcFiles, I18nTextCompilerOptions options)
        {
            var i18textSrc = new I18nTextSource();
            if (!srcFiles.Any()) return i18textSrc;

            Parallel.ForEach(srcFiles, srcFile =>
            {
                var fnameParts = Path.GetFileNameWithoutExtension(srcFile.Path).Split('.');
                var typeName = string.Join(".", fnameParts.Take(fnameParts.Length - 1));
                var langCode = fnameParts.Last();
                var srcText = File.ReadAllText(srcFile.Path, srcFile.Encoding);
                var textTable = DeserializeSrcText(srcText, Path.GetExtension(srcFile.Path).ToLower());

                var type = i18textSrc.Types.GetOrAdd(typeName, new I18nTextType());
                type.Langs[langCode] = textTable;
            });

            Parallel.ForEach(i18textSrc.Types.Values, type =>
            {
                type.TextKeys = type.Langs
                    .SelectMany(lang => lang.Value)
                    .Select(tt => tt.Key)
                    .OrderBy(key => key)
                    .Distinct()
                    .ToList();

                Parallel.ForEach(type.Langs, lang =>
                {
                    var textTable = lang.Value;
                    foreach (var textKey in type.TextKeys.Where(k => !textTable.ContainsKey(k)))
                    {
                        var text = type.Langs.Keys
                            .OrderBy(langCode => langCode.StartsWith("en") ? "0" : langCode)
                            .Select(langCode => type.Langs[langCode].TryGetValue(textKey, out var t) ? t : null)
                            .FirstOrDefault(t => t != null);
                        textTable[textKey] = text ?? textKey;
                    }
                });
            });

            return i18textSrc;
        }

        private static I18nTextTable DeserializeSrcText(string srcText, string fileNameExtension)
        {
            switch (fileNameExtension)
            {
                case ".json": return DeserializeSrcTextFromJson(srcText);
                case ".csv": return DeserializeSrcTextFromCsv(srcText);
                default: throw new I18nTextCompileException($"Unknown file type ({fileNameExtension}) as an I18n Text source file.");
            }
        }

        private static I18nTextTable DeserializeSrcTextFromJson(string srcText)
        {
            // NOTE:
            // a JSON.NET old version has problem that it can't deserialize ConcurrentDictionary directly.
            // Therefore, deserialize into normal dictionary at first, and second, re - constrauct as ConcurrentDictionary.
            var tableTextRaw = JsonConvert.DeserializeObject<Dictionary<string, string>>(srcText);
            return new I18nTextTable(tableTextRaw);
        }

        internal class KeyValue
        {
            public string Key { get; set; }

            public string Value { get; set; }
        }

        internal class CsvKeyValueMapping : CsvMapping<KeyValue>
        {
            public CsvKeyValueMapping() : base()
            {
                MapProperty(0, x => x.Key);
                MapProperty(1, x => x.Value);
            }
        }

        private static I18nTextTable DeserializeSrcTextFromCsv(string srcText)
        {
            var csvParser = new CsvParser<KeyValue>(
                new CsvParserOptions(skipHeader: false, fieldsSeparator: ','),
                new CsvKeyValueMapping());
            var tableTextRaw = csvParser.ReadFromString(new CsvReaderOptions(new[] { "\r\n", "\n" }), srcText)
                .ToDictionary(row => row.Result.Key, row => row.Result.Value);
            return new I18nTextTable(tableTextRaw);
        }

        private static void OutputTypesFiles(I18nTextCompilerOptions options, I18nTextSource i18textSrc)
        {
            if (!i18textSrc.Types.Any()) return;
            if (!Directory.Exists(options.TypesDirectory)) Directory.CreateDirectory(options.TypesDirectory);

            var types = i18textSrc.Types.Select(type =>
            {
                var typeFullName = options.NameSpace + "." + type.Key;
                var typeNameParts = typeFullName.Split('.');
                var typeNamespace = string.Join(".", typeNameParts.Take(typeNameParts.Length - 1));
                var typeName = typeNameParts.Last();
                var typeFilePath = Path.Combine(options.TypesDirectory, typeFullName + ".cs");
                return (type, typeNamespace, typeName, typeFilePath);
            }).ToArray();

            // Sweep old generated/should be purge type files.
            var existsTypeFiles = Directory.GetFiles(options.TypesDirectory, "*.cs");
            var shouldBeSweepedFiles = existsTypeFiles.Except(types.Select(t => t.typeFilePath));
            foreach (var shouldBeSweepedFile in shouldBeSweepedFiles)
            {
                if (File.ReadLines(shouldBeSweepedFile).Any(line => line == GeneratedMarker))
                {
                    File.Delete(shouldBeSweepedFile);
                }
            }

            Parallel.ForEach(types, ((KeyValuePair<string, I18nTextType> type, string typeNamespace, string typeName, string typeFilePath) arg) =>
            {
                var langs = arg.type.Value.Langs;
                var langParts = options.FallBackLanguage.Split('-');
                var fallbackLangs = langParts.Length > 1 ? new[] { options.FallBackLanguage, langParts[0] } : new[] { options.FallBackLanguage };
                var fallbackLang = fallbackLangs.FirstOrDefault(lang => langs.ContainsKey(lang));
                if (fallbackLang == null) throw new I18nTextCompileException($"IN1001: Could not find an I18n source text file of fallback language '{options.FallBackLanguage}', for '{options.NameSpace}.{arg.type.Key}'.");
                var textTable = langs[fallbackLang];

                var typeCode = new List<string>();
                typeCode.Add(GeneratedMarker);
                typeCode.Add($"namespace {arg.typeNamespace}");
                typeCode.Add("{");
                typeCode.Add($"    public partial class {arg.typeName} : global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextFallbackLanguage, global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextLateBinding");
                typeCode.Add("    {");
                typeCode.Add($"        string global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextFallbackLanguage.FallBackLanguage => \"{options.FallBackLanguage}\";");
                typeCode.Add("");
                typeCode.Add("        public string this[string key] => global::Toolbelt.Blazor.I18nText.I18nTextExtensions.GetFieldValue(this, key);");
                typeCode.Add("");
                var is1stLine = true;
                foreach (var textKey in arg.type.Value.TextKeys)
                {
                    if (!is1stLine) typeCode.Add("");
                    typeCode.Add($"        /// <summary>\"{SecurityElement.Escape(textTable[textKey])}\"</summary>");
                    typeCode.Add($"        public string {textKey};");
                    is1stLine = false;
                }
                typeCode.Add("    }");
                typeCode.Add("}");

                var skipOutput = false;
                if (File.Exists(arg.typeFilePath))
                {
                    var prevTypeCode = File.ReadAllLines(arg.typeFilePath);
                    skipOutput = prevTypeCode.SequenceEqual(typeCode);
                }

                if (!skipOutput) File.WriteAllLines(arg.typeFilePath, typeCode);
            });
        }

        private void OutputI18nTextJsonFiles(I18nTextCompilerOptions options, I18nTextSource i18textSrc)
        {
            if (!i18textSrc.Types.Any()) return;
            if (!Directory.Exists(options.OutDirectory)) Directory.CreateDirectory(options.OutDirectory);

            var types = i18textSrc.Types
                .SelectMany(type => type.Value.Langs.Select(lang => (lang, jsonPath: Path.Combine(options.OutDirectory, options.NameSpace + "." + type.Key + "." + lang.Key + ".json"))))
                .ToArray();

            // Sweep old generated/should be purge text json files.
            var existsTextJsonFiles = Directory.GetFiles(options.OutDirectory, "*.json");
            var shouldBeSweepedFiles = existsTextJsonFiles.Except(types.Select(t => t.jsonPath));
            foreach (var shouldBeSweepedFile in shouldBeSweepedFiles)
            {
                File.Delete(shouldBeSweepedFile);
            }

            Parallel.ForEach(types, ((KeyValuePair<string, I18nTextTable> lang, string jsonPath) arg) =>
            {
                var textTable = new SortedDictionary<string, string>(arg.lang.Value);
                var jsonText = JsonConvert.SerializeObject(textTable, Formatting.Indented);

                var skipOutput = false;
                if (File.Exists(arg.jsonPath))
                {
                    var prevJsonText = File.ReadAllText(arg.jsonPath);
                    skipOutput = prevJsonText == jsonText;
                }

                if (!skipOutput) File.WriteAllText(arg.jsonPath, jsonText);
            });
        }
    }
}
