using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Security;
using System.Security.Cryptography;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Toolbelt.Blazor.I18nText.Internals;
using Toolbelt.Blazor.I18nText.SourceGenerator.Inetrnals;

namespace Toolbelt.Blazor.I18nText
{
    public class I18nTextCompiler
    {
        private const string GeneratedMarker = "// <auto-generated by=\"the Blazor I18n Text compiler\" />";

        public bool Compile(IEnumerable<I18nTextSourceFile> srcFiles, I18nTextCompilerOptions options)
        {
            return Compile(srcFiles, options, beforeCompile: SweepTypeFilesShouldBePurged, saveCode: SaveTypeCodeToTypeFiles, CancellationToken.None);
        }

        public static bool Compile(
            IEnumerable<I18nTextSourceFile> srcFiles,
            I18nTextCompilerOptions options,
            Action<I18nTextCompilerOptions, I18nTextCompileItem, IEnumerable<string>> saveCode,
            CancellationToken cancellationToken)
        {
            return Compile(srcFiles, options, beforeCompile: null, saveCode, cancellationToken);
        }

        private static bool Compile(
            IEnumerable<I18nTextSourceFile> srcFiles,
            I18nTextCompilerOptions options,
            Action<I18nTextCompilerOptions, IEnumerable<I18nTextCompileItem>> beforeCompile,
            Action<I18nTextCompilerOptions, I18nTextCompileItem, IEnumerable<string>> saveCode,
            CancellationToken cancellationToken)
        {
            try
            {
                var i18textSrc = I18nTextSourceFile.Parse(srcFiles, options, cancellationToken);
                OutputI18nTextJsonFiles(options, i18textSrc, cancellationToken);
                OutputTypesFiles(options, i18textSrc, beforeCompile, saveCode, cancellationToken);
                return true;
            }
            catch (AggregateException e) when (e.InnerException is I18nTextCompileException compileException)
            {
                options.LogError(compileException);
                return false;
            }
            catch (I18nTextCompileException compileException)
            {
                options.LogError(compileException);
                return false;
            }
        }

        private static void OutputTypesFiles(
            I18nTextCompilerOptions options,
            I18nTextSource i18textSrc,
            Action<I18nTextCompilerOptions, IEnumerable<I18nTextCompileItem>> beforeCompile,
            Action<I18nTextCompilerOptions, I18nTextCompileItem, IEnumerable<string>> saveCode,
            CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (!i18textSrc.Types.Any()) return;

            var i18nTextCompilerItems = i18textSrc.Types.Select(type =>
            {
                var typeFullName = options.NameSpace + "." + type.Key;
                var typeNameParts = typeFullName.Split('.');
                var typeNamespace = string.Join(".", typeNameParts.Take(typeNameParts.Length - 1));
                var typeName = typeNameParts.Last();

                var typeFilePath = Path.Combine(options.TypesDirectory, typeFullName + ".cs");
                return new I18nTextCompileItem(type, typeNamespace, typeName, typeFilePath);
            }).ToArray();

            beforeCompile?.Invoke(options, i18nTextCompilerItems);
            cancellationToken.ThrowIfCancellationRequested();

            Parallel.ForEach(i18nTextCompilerItems, new ParallelOptions { CancellationToken = cancellationToken }, comilerItem =>
            {
                var langs = comilerItem.Type.Value.Langs;
                var langParts = options.FallBackLanguage.Split('-');
                var fallbackLangs = langParts.Length > 1 ? new[] { options.FallBackLanguage, langParts[0] } : new[] { options.FallBackLanguage };
                var fallbackLang = fallbackLangs.FirstOrDefault(lang => langs.ContainsKey(lang));
                if (fallbackLang == null) throw new I18nTextCompileException(DiagnosticCode.FallbackLangNotFound, $"Could not find an I18n source text file of fallback language '{options.FallBackLanguage}', for '{options.NameSpace}.{comilerItem.Type.Key}'.");
                var textTable = langs[fallbackLang];

                var hash = GenerateHash(comilerItem.Type.Value);
                cancellationToken.ThrowIfCancellationRequested();

                var typeCode = new List<string>();
                typeCode.Add(GeneratedMarker);
                typeCode.Add($"namespace {comilerItem.TypeNamespace}");
                typeCode.Add("{");
                typeCode.Add($"    public partial class {comilerItem.TypeName} : global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextFallbackLanguage, global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextLateBinding, global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextTableHash");
                typeCode.Add("    {");
                typeCode.Add($"        string global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextTableHash.Hash => \"{hash}\";");
                typeCode.Add("");
                typeCode.Add($"        string global::Toolbelt.Blazor.I18nText.Interfaces.I18nTextFallbackLanguage.FallBackLanguage => \"{options.FallBackLanguage}\";");
                typeCode.Add("");
                typeCode.Add("        public string this[string key] => global::Toolbelt.Blazor.I18nText.I18nTextExtensions.GetFieldValue(this, key);");
                typeCode.Add("");
                typeCode.Add("        public string GetValueByName(string propertyName)");
                typeCode.Add("        {");
                typeCode.Add("            var type = this.GetType();");
                typeCode.Add("            var typeName = type.Name;");
                typeCode.Add("            var value = type.GetProperty(propertyName)?.GetValue(this, null);");
                typeCode.Add("");
                typeCode.Add("            if (value == null)");
                typeCode.Add("                throw new ArgumentException($\"Provided property {propertyName} for object {typeName} was not found on the compiled object.\");");
                typeCode.Add("            ");
                typeCode.Add("            return value?.ToString()!;");
                typeCode.Add("        }");
                var is1stLine = true;
                foreach (var textKey in comilerItem.Type.Value.TextKeys)
                {
                    if (!is1stLine) typeCode.Add("");
                    typeCode.Add($"        /// <summary>\"{EscapeForXMLDocSummary(textTable[textKey])}\"</summary>");
                    typeCode.Add($"        public string {textKey};");
                    is1stLine = false;
                }
                typeCode.Add("    }");
                typeCode.Add("}");

                saveCode?.Invoke(options, comilerItem, typeCode);
            });
        }

        private static void SaveTypeCodeToTypeFiles(I18nTextCompilerOptions options, I18nTextCompileItem compileItem, IEnumerable<string> typeCode)
        {
            var skipOutput = false;
            if (File.Exists(compileItem.TypeFilePath))
            {
                var prevTypeCode = File.ReadAllLines(compileItem.TypeFilePath);
                skipOutput = prevTypeCode.SequenceEqual(typeCode);
            }

            if (!skipOutput)
            {
                if (!Directory.Exists(options.TypesDirectory)) Directory.CreateDirectory(options.TypesDirectory);
                File.WriteAllLines(compileItem.TypeFilePath, typeCode);
            }
        }

        /// <summary>
        /// Sweep old generated/should be purge type files.
        /// </summary>
        private static void SweepTypeFilesShouldBePurged(I18nTextCompilerOptions options, IEnumerable<I18nTextCompileItem> compilerItems)
        {
            SweepTypeFilesShouldBePurged(options, compilerItems, CancellationToken.None);
        }

        /// <summary>
        /// Sweep old generated/should be purge type files.
        /// </summary>
        internal static void SweepTypeFilesShouldBePurged(I18nTextCompilerOptions options, IEnumerable<I18nTextCompileItem> compilerItems, CancellationToken cancellationToken)
        {
            if (Directory.Exists(options.TypesDirectory))
            {
                var existsTypeFiles = Directory.GetFiles(options.TypesDirectory, "*.cs");
                var shouldBeSweepedFiles = existsTypeFiles.Except(compilerItems.Select(t => t.TypeFilePath));
                foreach (var shouldBeSweepedFile in shouldBeSweepedFiles)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    if (File.ReadLines(shouldBeSweepedFile).Any(line => line == GeneratedMarker))
                    {
                        File.Delete(shouldBeSweepedFile);
                    }
                }

                cancellationToken.ThrowIfCancellationRequested();
                if (!Directory.GetFileSystemEntries(options.TypesDirectory).Any())
                {
                    Directory.Delete(options.TypesDirectory, recursive: false);
                }
            }
        }

        internal static string GenerateHash(I18nTextType i18nText)
        {
            using var hash = SHA256.Create();
            using var stream = new I18nTextTableStream(i18nText);
            var hashBytes = hash.ComputeHash(stream);
            return ToBase36(hashBytes);
        }

        private static string ToBase36(byte[] hash)
        {
            const string chars = "0123456789abcdefghijklmnopqrstuvwxyz";

            var result = new char[10];
            var dividend = BigInteger.Abs(new BigInteger(hash.Take(9).ToArray()));
            for (var i = 0; i < 10; i++)
            {
                dividend = BigInteger.DivRem(dividend, 36, out var remainder);
                result[i] = chars[(int)remainder];
            }

            return new string(result);
        }

        private static string EscapeForXMLDocSummary(string text)
        {
            return SecurityElement.Escape(text).Replace("\r", "").Replace("\n", "<br/>");
        }

        private static void OutputI18nTextJsonFiles(I18nTextCompilerOptions options, I18nTextSource i18textSrc, CancellationToken cancellationToken)
        {
            cancellationToken.ThrowIfCancellationRequested();

            if (!i18textSrc.Types.Any()) return;
            if (!Directory.Exists(options.OutDirectory)) Directory.CreateDirectory(options.OutDirectory);

            var types = i18textSrc.Types
                .SelectMany(type => type.Value.Langs.Select(lang => (lang, jsonPath: Path.Combine(options.OutDirectory, options.NameSpace + "." + type.Key + "." + lang.Key + ".json"))))
                .ToArray();

            // Sweep old generated/should be purge text json files.
            var existsTextJsonFiles = Directory.GetFiles(options.OutDirectory, "*.json");
            var shouldBeSweepedFiles = existsTextJsonFiles.Except(types.Select(t => t.jsonPath));
            foreach (var shouldBeSweepedFile in shouldBeSweepedFiles)
            {
                cancellationToken.ThrowIfCancellationRequested();
                File.Delete(shouldBeSweepedFile);
            }

            Parallel.ForEach(types, new ParallelOptions { CancellationToken = cancellationToken }, ((KeyValuePair<string, I18nTextTable> lang, string jsonPath) arg) =>
            {
                var textTable = new SortedDictionary<string, string>(arg.lang.Value);
                var jsonText = JsonConvert.SerializeObject(textTable, Formatting.Indented);
                cancellationToken.ThrowIfCancellationRequested();

                var skipOutput = false;
                if (File.Exists(arg.jsonPath))
                {
                    var prevJsonText = File.ReadAllText(arg.jsonPath);
                    cancellationToken.ThrowIfCancellationRequested();
                    skipOutput = prevJsonText == jsonText;
                }

                if (!skipOutput) File.WriteAllText(arg.jsonPath, jsonText);
            });
        }
    }
}
